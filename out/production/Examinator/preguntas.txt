
¿Qué palabra clave se utiliza para declarar una constante en Java?
a) const
b) final
c) static
d) constant
 Respuesta correcta: b
Explicación: La palabra 'final' se utiliza para declarar constantes en Java.

¿Cuál es el tipo de datos para números enteros más pequeño en Java?
a) byte
b) short
c) int
d) long
 Respuesta correcta: a
Explicación: El tipo 'byte' usa solo 1 byte de memoria y va de -128 a 127.

¿Cuál es el valor predeterminado de un boolean en Java?
a) true
b) null
c) false
d) 0
 Respuesta correcta: c
Explicación: En Java, las variables boolean por defecto se inicializan como false.

¿Qué operador se utiliza para comparar igualdad en Java?
a) =
b) ==
c) equals
d) !=
 Respuesta correcta: b
Explicación: '==' se usa para comparar valores primitivos. Para objetos, se recomienda usar equals().

¿Cuál de las siguientes no es una palabra reservada en Java?
a) static
b) try
c) new
d) define
 Respuesta correcta: d
Explicación: 'define' no es una palabra reservada en Java, aunque lo es en otros lenguajes como C.

¿Qué clase se utiliza para leer datos desde la consola?
a) InputReader
b) Scanner
c) ConsoleReader
d) BufferReader
 Respuesta correcta: b
Explicación: Scanner es la clase comúnmente usada para leer datos desde consola en Java.

¿Cuál de las siguientes estructuras es una clase contenedora?
a) Array
b) List
c) int
d) char
 Respuesta correcta: b
Explicación: List es una interfaz de colección que representa una lista ordenada de elementos.

¿Cuál es la salida de System.out.println(3 + "4")?
a) 7
b) 34
c) Error
d) "7"
 Respuesta correcta: b
Explicación: Se concatena 3 con el String "4", dando como resultado "34".

¿Qué significa que Java sea un lenguaje fuertemente tipado?
a) Que se puede cambiar el tipo de una variable libremente.
b) Que se deben declarar todos los tipos de datos.
c) Que es sensible a mayúsculas.
d) Que no se pueden usar tipos primitivos.
 Respuesta correcta: b
Explicación: En Java todos los tipos deben ser declarados explícitamente y no se permite el cambio de tipo implícito en la mayoría de los casos.

Los operadores lógicos operan con valores booleanos, resultando:
a) Valores enteros.
b) Valores enteros y booleanos.
c) Otros tipos de valores.
d) Solo valores booleanos.
 Respuesta correcta: d.
 Explicación: Los operadores lógicos trabajan únicamente con valores booleanos (true o false).

La evaluación de una expresión relacional puede generar un valor de tipo:
a) Entero
b) Real
c) Booleano
d) Todos los anteriores
 Respuesta correcta: c
 Explicación: Las expresiones relacionales devuelven un valor booleano (true o false).

La expresión 3==3 && 2<3 && 1!=2 resulta:
a) Cierto
b) Falso
c) No se puede evaluar
d) No genera un booleano, ya que la expresión es aritmética
 Respuesta correcta: a
 Explicación: Todas las comparaciones son verdaderas, por tanto el resultado es true (cierto).

La siguiente expresión, donde interviene la variable booleana a: 3!=3 || a || 1<2, resulta:
a) Dependerá del valor a
b) Cierto
c) Falso
d) No se puede evaluar
 Respuesta correcta: b
 Explicación: Aunque 3!=3 es falso, 1<2 es verdadero, por lo que el resultado es true (corto circuito lógico).

Elige los valores de las variables enteras (a, b y c) que permiten que la evaluación de la siguiente expresión sea cierta: a<b && b!=c && b<=c:
a) a = 1, b = 1, c = 2
b) a = 2, b = 1, c = 2
c) a = 1, b = 2, c = 2
d) a = 1, b = 2, c = 3
 Respuesta correcta: c
 Explicación: 1<2 (true), 2!=2 (false), así que d es la única que cumple todas las condiciones.

El bloque de instrucciones de una sentencia if se ejecutará:
a) Siempre
b) Nunca
c) Dependerá de la evaluación de la expresión utilizada
d) Todas las respuestas anteriores son correctas
 Respuesta correcta: c
 Explicación: Solo se ejecuta si la condición del if se evalúa como true.

En una sentencia if-else los bloques de instrucciones (bloque true y bloque false) pueden ejecutarse:
a) Simultáneamente
b) Es posible, dependiendo de la condición utilizada, que no se ejecute ninguno
c) Siempre se ejecutará al menos uno y son excluyentes
d) Todas las anteriores son incorrectas
 Respuesta correcta: c
 Explicación: En un if-else siempre se ejecuta uno de los dos bloques, pero nunca ambos.

¿Qué valor toma la variable a en la siguiente expresión: a = 1<2 ? 3 : 4?
a) 1
b) 2
c) 3
d) 4
 Respuesta correcta: c
 Explicación: Como 1<2 es true, se ejecuta el primer valor: 3.

La cláusula default en la sentencia switch es:
a) Obligatoria y tiene que ser la última que aparezca
b) Obligatoria, pero puede aparecer en cualquier lugar
c) Opcional y tiene que ser la última que aparezca
d) Opcional y puede usarse en cualquier lugar
 Respuesta correcta: d
 Explicación: default es opcional y puede colocarse en cualquier lugar del switch.

Realiza una traza del siguiente fragmento de código y selecciona el valor que toma finalmente la variable a:
a = 0;
switch (a + 1) {
    case 0:
        a = 2;
    case 1:
        a = 3;
    case 2:
        a++;
        break;
    case 3:
        a--;
        break;
}
a) a = 2.
b) a= 3.
c) a = null;
d) a = 4;
 Respuesta correcta: d
 a comienza con el valor 0. Al evaluar switch (a + 1), el resultado es 1, por lo que entra en el case 1. y continua por la ausencia de break. suma 1 y sale resultado a = 4

¿Cuál es el operador lógico 'AND' en Java?
a) &
b) &&
c) and
d) ||
Respuesta correcta: b
Explicación: En Java '&&' es el operador lógico AND que evalúa condiciones booleanas.

¿Qué instrucción se usa para ejecutar código solo si una condición es verdadera?
a) while
b) for
c) if
d) switch
Respuesta correcta: c
Explicación: 'if' evalúa condiciones booleanas para decidir si ejecutar un bloque de código.


Un bucle do-while se ejecutará, como mínimo:
a) Cero veces
b) Una vez
c) Infinitas veces
d) Ninguna de las opciones anteriores es correcta
 Respuesta correcta: b
 El bucle do-while ejecuta primero el bloque de código y luego evalúa la condición. Por tanto, se ejecuta al menos una vez.

El uso de llaves para encerrar el bloque de instrucciones de un bucle:
a) Es siempre opcional
b) Es opcional si el bloque está formado por una única instrucción
c) En cualquier caso, su uso es obligatorio
d) El programador decide su uso
 Respuesta correcta: b
 Si el bucle contiene solo una instrucción, las llaves son opcionales, aunque su uso es recomendable para claridad.

La instrucción que permite detener completamente las iteraciones de un bucle es:
a) stop
b) break
c) continue
d) finish
 Respuesta correcta: b
 La instrucción `break` finaliza inmediatamente la ejecución del bucle en curso.

La instrucción que permite detener la iteración actual de un bucle, continuando con la siguiente, si procede, es:
a) stop
b) break
c) continue
d) finish
 Respuesta correcta: c
 `continue` salta el resto del código de la iteración actual y pasa a la siguiente, si existe.

De un bucle do-while, cuya condición depende de una serie de variables que en el bloque de instrucciones no se modifican, se puede afirmar:
a) Que su número de iteraciones será siempre una
b) Que el número de iteraciones será siempre par
c) Que las variables cambiarán automáticamente en cualquier momento
d) Ninguna de las opciones anteriores es correcta
 Respuesta correcta: a
 Si las variables no cambian en el bucle y no satisfacen la condición, solo se ejecutará una vez por la estructura del do-while.

¿Cuántas veces se ejecutará el bloque de instrucciones del bucle más interno en el siguiente fragmento de código?
for (i = 1; i <= 10; i++) {
    for (i = 1; i <= 5; i++) {
        System.out.println("Hola");
    }
}
a) 10 veces
b) 5 veces
c) 50 veces
d) Infinitas veces
 Respuesta correcta: d
 Al usar la misma variable `i` en ambos bucles, el control del bucle externo se rompe, lo que puede provocar un bucle infinito.

¿Cuál de los siguientes bucles se ejecuta al menos una vez?
a) for
b) while
c) do-while
d) foreach
 Respuesta correcta: c
 Explicación: 'do-while' ejecuta primero el bloque de código y luego evalúa la condición.

¿Qué bucle se usa comúnmente cuando se conoce el número de iteraciones?
a) while
b) do-while
c) for
d) switch
 Respuesta correcta: c
 Explicación: El bucle 'for' es ideal para contar iteraciones con índice conocido.

Analiza el siguiente código y busca qué valores de a y b implican un menor número de iteraciones:
for (int i = a; i <= a + b; i++) {
    for (int j = a + b; j >= 0; j--) {
        // ...
    }
}
a) a = 1 y b = 3
b) a = 3 y b = 1
c) a = 1 y b = 1
d) a = 3 y b = 3
 Respuesta correcta: c
 Con a = 1 y b = 1, el rango del bucle exterior es mínimo (1 hasta 2), lo que reduce las iteraciones al mínimo posible.

En cada iteración, el incremento de un bucle for se ejecuta:
a) En primer lugar
b) Después de la inicialización
c) Después de evaluar la condición
d) Justo al finalizar cada iteración
 Respuesta correcta: d
 El incremento se realiza al final de cada iteración, justo antes de reevaluar la condición.

Una variable que se declara dentro de su bloque de instrucciones solo se podrá utilizar:
a) En cualquier parte del programa
b) En todos los bucles
c) Dentro del bloque de instrucciones donde se ha declarado
d) Todas las opciones anteriores son correctas
 Respuesta correcta: c
 Una variable local solo es accesible dentro del bloque en el que se ha declarado.

En un bucle for, la inicialización, condición e incremento son:
a) Todos obligatorios
b) Todos opcionales
c) La inicialización siempre es obligatoria
d) La condición siempre es obligatoria
 Respuesta correcta: b
 Técnicamente, los tres componentes del bucle for son opcionales en Java, aunque se usan por claridad y control.

En el caso de que una función devuelva un valor, ¿cuál es la recomendación con respecto a la instrucción return?
a) Utilizar tantos como hagan falta
b) Emplear tantos como hagan falta, pero siempre que se encuentren en bloques de instrucciones distintas
c) Usar solo uno
d) Utilizar solo uno, que será siempre la primera instrucción de la función
 Respuesta correcta: c
 Usar un solo `return` mejora la legibilidad del código y facilita el mantenimiento y la depuración.

¿Cuáles de las siguientes operaciones se pueden implementar fácilmente mediante funciones recursivas?
a) an = a × an-1
b) esPar(n) = esImpar(n − 1) y esImpar(n) = esPar(n − 1)
c) suma(a, b) = suma(a + 1, b − 1)
d) Todas las respuestas anteriores son correctas
 Respuesta correcta: d
 Todas estas definiciones son recursivas y pueden implementarse eficazmente con funciones recursivas.

En los identificadores de las funciones, al igual que en los de las variables, se recomienda utilizar la siguiente nomenclatura:
a) suma_notas_alumnos()
b) sumanotasalumnos()
c) SumaNotasAlumnos()
d) sumaNotasAlumnos()
 Respuesta correcta: d
 La convención de Java para nombres de métodos es camelCase: se empieza en minúscula y cada palabra adicional inicia con mayúscula.

¿Qué palabra clave define un método que no devuelve valor?
a) void
b) null
c) return
d) static
 Respuesta correcta: a
 'void' se utiliza para indicar que un método no retorna ningún valor.

¿Cómo se llama un método dentro de una clase en Java?
a) función
b) subrutina
c) método
d) operador
 Respuesta correcta: c
 En Java, una función que está dentro de una clase se denomina 'método'.

Los parámetros en la llamada a una función en Java pueden ser opcionales si:
a) Todos los parámetros son del mismo tipo
b) Todos los parámetros son de distinto tipo
c) Nunca pueden ser opcionales
d) Siempre que el tipo devuelto no sea void
 Respuesta correcta: c
 En Java, no existen parámetros opcionales de forma directa. Hay que simularlo con sobrecarga de métodos.

Una variable local (declarada dentro de una función) puede usarse:
a) En cualquier lugar del código
b) Solo dentro de main()
c) Solo en la función donde se ha declarado
d) Ninguna de las opciones anteriores es correcta
 Respuesta correcta: c
 Las variables locales solo existen dentro del bloque donde fueron declaradas.

El tipo devuelto de todas las funciones definidas en nuestro programa tiene que ser siempre:
a) int
b) double
c) void
d) Ninguna de las opciones anteriores es correcta
 Respuesta correcta: d
 El tipo de retorno puede ser cualquiera, no solo los mencionados. Incluso pueden devolver objetos o listas.

¿Qué instrucción permite a una función devolver un valor?
a) value
b) return
c) static
d) function
 Respuesta correcta: b
 'return' es la instrucción que se utiliza para devolver un valor desde una función.

La forma de distinguir entre dos o más funciones sobrecargadas es:
a) Mediante su nombre
b) Mediante el tipo devuelto
c) Mediante el nombre de sus parámetros
d) Mediante su lista de parámetros: número o tipos
 Respuesta correcta: d
 Java permite la sobrecarga si cambian el número o tipo de los parámetros, no el nombre ni el tipo de retorno.

¿Cuál es la definición de una función recursiva?
a) Es aquella que se invoca desde dentro de su propio bloque de instrucciones
b) Es aquella cuyo nombre permite la sobrecarga y además realiza alguna comprobación mediante if
c) Es aquella cuyo bloque de instrucciones utiliza alguna sentencia if (lo que llamamos caso base)
d) Es aquella que genera un bucle infinito
 Respuesta correcta: a
 Una función recursiva es aquella que se llama a sí misma dentro de su propia definición.

El paso de parámetros a una función en Java es siempre:
a) Un paso de parámetros por copia
b) Un paso de parámetros por desplazamiento
c) Un paso de parámetros recursivo
d) Un paso de parámetros funcional
 Respuesta correcta: a
 En Java, los tipos primitivos se pasan por valor (copia). En objetos se pasa una copia de la referencia.

La comparación del contenido (los elementos) de dos tablas se realiza utilizando:
a) Arrays.compare()
b) El operador ==
c) Arrays.equals()
d) Arrays.same()
 Respuesta correcta: c
 El método `Arrays.equals()` compara el contenido de dos arrays elemento por elemento. El operador `==` compara referencias, no contenido.

¿Qué condición tiene que cumplir una tabla para que podamos realizar búsquedas dicotómicas en ella?
a) Que esté ordenada
b) Que esté ordenada y sea una tabla de enteros
c) Que no esté ordenada
d) No importa si la tabla está ordenada, lo realmente importante es que sea de algún tipo numérico
 Respuesta correcta: a
 La búsqueda binaria o dicotómica solo es válida si el array está previamente ordenado. No importa el tipo de datos.

¿Cuál es la principal diferencia entre Arrays.copyOf() y System.arraycopy()?
a) No existe diferencia alguna, ambos métodos son idénticos
b) Arrays.copyOf() copia mientras System.arraycopy() copia y compara
c) Arrays.copyOf() copia entre tablas existentes mientras System.arraycopy() crea una nueva tabla y copia en ella
d) Arrays.copyOf() crea una nueva tabla y copia en ella mientras System.arraycopy() solo copia entre tablas ya creadas
 Respuesta correcta: d
 `Arrays.copyOf()` crea automáticamente un nuevo array y copia los elementos. `System.arraycopy()` copia entre arrays ya existentes.

¿Cómo se declara un array de enteros en Java?
a) int array = new int[];
b) int[] array;
c) int array[] = {};
d) array int = new array();
 Respuesta correcta: b
 La forma correcta de declarar un array en Java es `int[] nombreArray;`, con el tipo seguido por corchetes.

Una tabla puede almacenar datos de distintos tipos, como por ejemplo enteros, booleanos, reales, etcétera:
a) Cierto, las tablas siempre pueden almacenar datos de distintos tipos
b) Falso, las tablas solo pueden almacenar datos de un único tipo
c) Puede almacenar datos de distintos tipos siempre que estos sean numéricos
d) Puede almacenar datos de distintos tipos siempre que la longitud de los datos sea idéntica
 Respuesta correcta: b
 En Java, los arrays son homogéneos: todos los elementos deben ser del mismo tipo.

En Java, la numeración de los índices que determina la identificación de cada elemento de una tabla comienza en:
a) Cero
b) Uno
c) Depende del tipo de dato de la tabla
d) Es configurable por el usuario
 Respuesta correcta: a
 Los arrays en Java comienzan siempre en el índice 0.

Si en una tabla de 10 elementos utilizamos el elemento con índice 11 (que se encuentra fuera de rango):
a) Al salir del rango de la longitud, Java redimensiona la tabla de forma automática
b) No es posible y produce un error
c) Las tablas tienen un comportamiento circular y utilizar el índice 11 es idéntico a utilizar el índice 1
d) Ninguna de las anteriores respuestas es cierta
 Respuesta correcta: b
 Acceder a un índice fuera del rango produce una excepción `ArrayIndexOutOfBoundsException`.

¿Qué método de la clase Arrays permite realizar una búsqueda dicotómica en una tabla?
a) Arrays.search()
b) Arrays.find()
c) Arrays.binarySearch()
d) Cualquiera de los métodos anteriores realiza una búsqueda
 Respuesta correcta: c
 El método `Arrays.binarySearch()` realiza una búsqueda binaria, pero solo si el array está previamente ordenado.

Con respecto a las tablas, el operador new:
a) Destruye, crea y redimensiona tablas
b) Destruye y crea tablas
c) Crea tablas
d) Destruye las tablas
 Respuesta correcta: c
 El operador `new` se usa para crear nuevas instancias de arrays, no para destruir.

La forma de invocar al recolector de basura es:
a) Mediante System.garbageCollector()
b) Mediante el operador new
c) Mediante Arrays.garbageCollector()
d) Ninguna de las anteriores respuestas es correcta
 Respuesta correcta: d
 El recolector de basura puede sugerirse con `System.gc()`, pero no se garantiza su ejecución inmediata.

La forma de conocer la longitud de una tabla t es mediante:
a) t.size
b) t.elements
c) t.length
d) Arrays.size(t)
 Respuesta correcta: c
 En Java, la propiedad `length` permite conocer el tamaño de un array.

¿Cuál es el índice del primer elemento de un array en Java?
a) 0
b) 1
c) -1
d) depende
 Respuesta correcta: a
 Los arrays en Java siempre comienzan en el índice 0.

La forma de concatenar dos cadenas es mediante:
a) El operador +
b) El operador +=
c) El método concat()
d) Todas permiten concatenar cadenas
 Respuesta correcta: d
 En Java puedes concatenar cadenas usando `+`, `+=` o `concat()`; todas son válidas para unir Strings.

El método que permite eliminar los caracteres blancos del principio y el final de una cadena es:
a) isWhiteSpace()
b) deleteWhiteSpace()
c) strip()
d) stripLeading()
 Respuesta correcta: c
 `strip()` elimina los espacios en blanco al inicio y al final de la cadena, incluido soporte para Unicode.

Existe una relación entre las cadenas (clase String) y las tablas de caracteres (char[]). ¿Qué métodos permiten convertir un String en un char[]?
a) toCharArray()
b) valueOf()
c) convertString()
d) empty()
 Respuesta correcta: a
 `toCharArray()` convierte una cadena String en un array de caracteres (char[]).

En Java, al igual que en otros muchos lenguajes de programación, las secuencias de escape se escriben mediante:
a) Dos puntos (:)
b) El carácter U mayúscula (U)
c) El carácter u minúscula (u)
d) Una barra invertida (\)
 Respuesta correcta: d
 Las secuencias de escape en Java usan la barra invertida `\`, como en `\n`, `\t`, etc.

La clase Character se encuentra ubicada en el paquete:
a) java.util
b) java.character
c) java.lang
d) java.unicode
 Respuesta correcta: c
 La clase `Character` pertenece al paquete `java.lang`, que se importa automáticamente.

La aritmética de caracteres permite que exista una fuerte relación entre el tipo char y el tipo int. Sabiendo que el carácter ‘a’ tiene una representación numérica de 0x61, ¿cómo conseguiremos mostrar el carácter ‘i’ por consola, a partir de la siguiente variable?
int codepoint = 0x61;
a) System.out.println((char)(codepoint + '8'));
b) System.out.println((char)(codepoint - '8'));
c) System.out.println((char)(codepoint - 8));
d) System.out.println((char)(codepoint + 8));
 Respuesta correcta: d
 'a' (0x61) más 8 en valor decimal nos da 'i'. El casting `(char)` convierte el valor numérico en carácter.

Marca la opción que devuelve true:
a) Character.isLetter('2');
b) Character.isUpperCase('2');
c) Character.isLowerCase('2');
d) Character.isLetterOrDigit('2');
 Respuesta correcta: d
 '2' no es letra, pero sí es dígito. `isLetterOrDigit()` devuelve true si el carácter es letra o número.

Señala qué opción es cierta:
a) ‘a’ es un carácter
b) ‘a’ es una cadena de caracteres
c) “a” es un carácter
d) Todas las opciones anteriores son ciertas
 Respuesta correcta: a
 'a' entre comillas simples es un `char`. "a" (comillas dobles) es un String, por lo tanto no es un carácter.

La forma correcta de comparar alfabéticamente dos cadenas es mediante:
a) El operador ==
b) El método equal() de String
c) El método equal() de Character
d) Todas permiten comparar dos cadenas
 Respuesta correcta: b
 En realidad, el método correcto es `equals()` de la clase String, no `equal()` ni el operador `==`.

La forma de extraer el cuarto carácter de la cadena contenida en la variable cad es mediante:
a) cad.indexOf(3)
b) cad.charAt(3)
c) cad.position(3)
d) cad.extract(3)
 Respuesta correcta: b
 `charAt(3)` accede al carácter en la posición 4, ya que los índices comienzan en 0.

¿Qué clase se utiliza para trabajar con cadenas en Java?
a) char
b) Character
c) String
d) Text
 Respuesta correcta: c
 La clase `String` permite manipular secuencias de texto en Java.

¿Cuál es el método para obtener la longitud de una cadena?
a) length()
b) size()
c) getLength()
d) count()
 Respuesta correcta: a
 `length()` devuelve el número de caracteres que tiene un objeto `String`.

¿Qué palabra clave se usa para definir una clase en Java?
a) object
b) define
c) class
d) type
 Respuesta correcta: c
 La palabra clave `class` se utiliza para declarar una nueva clase en Java.

¿Qué tipo de método se llama sin necesidad de crear una instancia?
a) privado
b) void
c) abstracto
d) estático
 Respuesta correcta: d
 Los métodos `static` se pueden invocar directamente desde la clase, sin necesidad de crear un objeto.

Dos clases se consideran vecinas siempre y cuando:
a) Sean visibles
b) Ambas dispongan del mismo número de constructores
c) Pertenezcan al mismo paquete
d) Todo lo anterior ha de cumplirse para que dos clases sean vecinas
 Respuesta correcta: c
 Las clases se consideran vecinas si pertenecen al mismo paquete.

Un miembro cuyo modificador de acceso es private será visible desde:
a) Todas las clases vecinas
b) Todas las clases externas
c) Es indistinto el paquete, pero será visible siempre que se importe la clase que lo contiene
d) Ninguna de las respuestas anteriores
 Respuesta correcta: d
 Los miembros `private` solo son accesibles dentro de la clase donde se declaran.

Si desde un constructor queremos invocar a otro constructor de la misma clase, tendremos que usar:
a) set()
b) get()
c) this()
d) this.
 Respuesta correcta: c
 `this()` se utiliza para llamar a otro constructor de la misma clase.

Si por error dejamos un objeto sin ninguna referencia, siempre podremos volver a referenciarlo mediante:
a) La referencia this
b) La referencia null
c) Utilizando new
d) Es imposible
 Respuesta correcta: d
 Si no existen referencias a un objeto, este es elegible para recolección de basura y no puede ser accedido nuevamente.

¿Qué hace el operador new?
a) Construye un objeto, invoca al constructor y devuelve su referencia
b) Construye un objeto, comprueba que su clase esté importada y devuelve su referencia
c) Busca en la memoria un objeto del mismo tipo, invoca al constructor y devuelve su referencia
d) Busca en memoria un objeto del mismo tipo y devuelve su referencia
 Respuesta correcta: a
 El operador `new` crea una nueva instancia de una clase e invoca su constructor.

Cuando hablamos de miembros de una clase, nos estamos refiriendo a:
a) Todos los atributos
b) Todos los métodos
c) Todos los atributos y métodos, indistintamente de los modificadores de acceso utilizados
d) Todos los atributos y métodos que son visibles por sus clases vecinas
 Respuesta correcta: c
 Se consideran miembros todos los atributos y métodos definidos en una clase.

En la definición de una clase, los únicos modificadores de acceso que se pueden utilizar son:
a) public
b) public y el modificador de acceso por defecto
c) public, el modificador de acceso por defecto y private
d) El modificador class
 Respuesta correcta: b
 Una clase en Java puede ser `public` o tener acceso por defecto (sin modificador). `private` no se permite para clases top-level.

¿Qué diferencia un atributo estático definido en una clase de otro que no lo es?
a) El atributo estático es visible por todas las clases vecinas, mientras que el no estático solo será visible para las clases que usen importación
b) Solo existe una copia del atributo estático en la clase, mientras que el atributo no estático tendrá una copia en cada uno de los objetos
c) Existe una copia del atributo estático en todos y cada uno de los objetos, mientras que del atributo no estático solo existe una copia en la clase
d) Ambos disponen de copias en cada objeto, pero el atributo no estático es accesible mediante la clase y el no estático es accesible mediante los objetos
 Respuesta correcta: b
 Los atributos estáticos pertenecen a la clase y solo hay una copia compartida, mientras que los no estáticos son propios de cada objeto.

¿Qué efecto tienen las siguientes líneas de código?
Cliente c;
c.nombre = "Pepita";
a) Inicializa el atributo nombre de Cliente con el valor «Pepita»
b) Invoca al constructor y posteriormente asigna el valor «Pepita» al atributo nombre, siempre y cuando este sea público
c) Si el atributo nombre es público, se le asigna un valor, pero si el atributo es privado, producirá un error
d) Siempre produce un error
 Respuesta correcta: d
 `Cliente c;` declara una referencia pero no crea un objeto. No se puede acceder a atributos sin instanciar con `new`.

La ocultación de atributos puede definirse como:
a) El proceso en el que un atributo pasa de ser público a privado
b) El proceso en el que se define una variable local (en un método) con el mismo identificador que un atributo
c) El proceso en el que un atributo estático deja de serlo
d) Todas las respuestas anteriores son correctas
 Respuesta correcta: b
 La ocultación ocurre cuando una variable local tiene el mismo nombre que un atributo de clase, ocultándolo dentro de su bloque.

La selección dinámica de métodos:
a) Se produce cuando una variable cambia de valor durante la ejecución de un programa
b) Es el cambio de tipo de una variable en tiempo de ejecución
c) Es la asignación de un mismo objeto a más de una variable en tiempo de ejecución
d) Es la ejecución de distintas implementaciones de un mismo método, asignando objetos de distintas clases a una misma variable, en tiempo de ejecución
 Respuesta correcta: d
 Esto se llama polimorfismo. Se ejecuta el método correspondiente al tipo real del objeto, no al tipo de la variable.

¿Cuál de las siguientes afirmaciones sobre el método super() es correcta?
a) Sirve para llamar al constructor de la superclase
b) Sirve para invocar un método escrito más arriba en el código
c) Sirve para llamar a cualquier método de la superclase
d) Sirve para hacer referencia a un atributo de la superclase
 Respuesta correcta: a
 `super()` se usa para invocar explícitamente al constructor de la superclase desde una subclase.

Sobre una subclase es correcto afirmar que:
a) Tiene menos atributos que su superclase
b) Tiene menos miembros que su superclase
c) Hereda los miembros no privados de su superclase
d) Hereda todos los miembros de su superclase
 Respuesta correcta: c
 Una subclase hereda los miembros públicos y protegidos, pero no los privados.

En relación con las clases abstractas es correcto señalar que:
a) Implementan todos sus métodos
b) No implementan ningún método
c) No tienen atributos
d) Tienen algún método abstracto
 Respuesta correcta: d
 Las clases abstractas pueden tener métodos implementados, pero deben incluir al menos un método abstracto.

¿En qué consiste la sustitución u overriding?
a) En sustituir un método heredado por otro implementado en la propia clase
b) En sustituir un atributo por otro del mismo nombre
c) En sustituir una clase por una subclase
d) En sustituir un valor de una variable por otro
 Respuesta correcta: a
 Overriding es redefinir un método heredado en la subclase, respetando su firma.

Sobre la clase Object es cierto indicar que:
a) Es abstracta
b) Hereda de todas las demás
c) Tiene todos sus métodos abstractos
d) Es superclase de todas las demás clases
 Respuesta correcta: d
 Todas las clases en Java heredan directa o indirectamente de `Object`.

¿Cuál de las siguientes afirmaciones sobre el método equals() es correcta?
a) Hay que implementarlo, ya que es abstracto
b) Sirve para comparar solo objetos de la clase Object
c) Se hereda de Object, pero debemos reimplementarlo al definirlo en una clase
d) No hay que implementarlo, ya que se hereda de Object
 Respuesta correcta: c
 Aunque `equals()` está implementado en `Object`, conviene sobreescribirlo para personalizar la comparación.

¿Cuál de las siguientes afirmaciones sobre el método toString() es correcta?
a) Sirve para mostrar la información que nos interesa de un objeto
b) Convierte automáticamente un objeto en una cadena
c) Encadena varios objetos
d) Es un método abstracto de Object que tenemos que implementar
 Respuesta correcta: a
 `toString()` devuelve una representación textual del objeto. Se puede sobrescribir para personalizarla.

¿Cuál de las siguientes afirmaciones sobre el método getClass() es correcta?
a) Convierte los objetos en clases
b) Obtiene la clase a la que pertenece un objeto
c) Obtiene la superclase de una clase
d) Obtiene una clase a partir de su nombre
 Respuesta correcta: b
 `getClass()` devuelve un objeto de tipo `Class` que representa la clase real del objeto.

Una clase puede heredar:
a) De una clase
b) De dos clases
c) De todas las clases que queramos
d) Solo de la clase Object
 Respuesta correcta: a
 Java solo permite herencia simple: una clase puede heredar de una única superclase.
¿Cuál es la palabra clave para heredar una clase?
a) inherits
b) extends
c) super
d) base
 Respuesta correcta: b
 'extends' se usa para heredar una clase en Java.

¿Qué método se usa para llamar al constructor de la superclase?
a) super()
b) parent()
c) base()
d) this()
 Respuesta correcta: a
 'super()' se usa para llamar al constructor de la clase base.

Sobre una subclase es correcto afirmar que:
a) Tiene menos atributos que su superclase.
b) Tiene menos miembros que su superclase.
c) Hereda los miembros no privados de su superclase.
d) Hereda todos los miembros de su superclase.
 Respuesta correcta: c
 Una subclase hereda los miembros públicos y protegidos de su superclase, no los privados.

En relación con las clases abstractas es correcto señalar que:
a) Implementan todos sus métodos.
b) No implementan ningún método.
c) No tienen atributos.
d) Tienen algún método abstracto.
 Respuesta correcta: d
 Las clases abstractas pueden tener métodos implementados y atributos, pero deben tener al menos un método abstracto.

¿En qué consiste la sustitución u overriding?
a) En sustituir un método heredado por otro implementado en la propia clase.
b) En sustituir un atributo por otro del mismo nombre.
c) En sustituir una clase por una subclase.
d) En sustituir un valor de una variable por otro.
 Respuesta correcta: a
 Overriding es redefinir un método heredado en una subclase con una nueva implementación.

Sobre la clase Object es cierto indicar que:
a) Es abstracta.
b) Hereda de todas las demás.
c) Tiene todos sus métodos abstractos.
d) Es superclase de todas las demás clases.
 Respuesta correcta: d
 Object es la superclase de todas las clases en Java.

¿Cuál de las siguientes afirmaciones sobre el método equals() es correcta?
a) Hay que implementarlo, ya que es abstracto.
b) Sirve para comparar solo objetos de la clase Object.
c) Se hereda de Object, pero debemos reimplementarlo al definirlo en una clase.
d) No hay que implementarlo, ya que se hereda de Object.
 Respuesta correcta: c
 Se hereda de Object, pero se recomienda sobrescribirlo para una comparación personalizada.

¿Cuál de las siguientes afirmaciones sobre el método toString() es correcta?
a) Sirve para mostrar la información que nos interesa de un objeto.
b) Convierte automáticamente un objeto en una cadena.
c) Encadena varios objetos.
d) Es un método abstracto de Object que tenemos que implementar.
 Respuesta correcta: a
 toString() sirve para devolver una representación textual personalizada de un objeto.

¿Cuál de las siguientes afirmaciones sobre el método getClass() es correcta?
a) Convierte los objetos en clases.
b) Obtiene la clase a la que pertenece un objeto.
c) Obtiene la superclase de una clase.
d) Obtiene una clase a partir de su nombre.
 Respuesta correcta: b
 getClass() devuelve la clase real del objeto en tiempo de ejecución.

Una clase puede heredar:
a) De una clase.
b) De dos clases.
c) De todas las clases que queramos.
d) Solo de la clase Object.
 Respuesta correcta: a
 En Java solo se permite heredar de una única clase (herencia simple).

La selección dinámica de métodos:
a) Se produce cuando una variable cambia de valor durante la ejecución de un programa.
b) Es el cambio de tipo de una variable en tiempo de ejecución.
c) Es la asignación de un mismo objeto a más de una variable en tiempo de ejecución.
d) Es la ejecución de distintas implementaciones de un mismo método, asignando objetos de distintas clases a una misma variable, en tiempo de ejecución.
 Respuesta correcta: d
 Esto es polimorfismo: permite ejecutar la versión del método correspondiente al tipo real del objeto.

¿Cuál de las siguientes afirmaciones sobre el método super() es correcta?
a) Sirve para llamar al constructor de la superclase.
b) Sirve para invocar un método escrito más arriba en el código.
c) Sirve para llamar a cualquier método de la superclase.
d) Sirve para hacer referencia a un atributo de la superclase.
 Respuesta correcta: a
 super() se usa para llamar al constructor de la clase base desde una subclase.

¿Cuál es el tipo de retorno del método main en Java?
a) void
b) int
c) String
d) boolean
 Respuesta correcta: a
 El método main debe ser public static void main(String[] args), por eso retorna void.

¿Qué palabra clave se utiliza para heredar una clase en Java?
a) this
b) extends
c) implements
d) instanceof
 Respuesta correcta: b
 La palabra clave 'extends' se utiliza para heredar de una clase base.

¿Qué estructura se usa para seleccionar múltiples opciones en Java?
a) if
b) for
c) switch
d) while
 Respuesta correcta: c
 La estructura 'switch' permite seleccionar múltiples casos según el valor de una expresión.

¿Cuál es el valor predeterminado de un boolean en Java?
a) true
b) null
c) false
d) 0
 Respuesta correcta: c
 En Java, las variables boolean por defecto se inicializan como false.

¿Qué operador se utiliza para comparar igualdad en Java?
a) =
b) ==
c) equals
d) !=
 Respuesta correcta: b
 '==' se usa para comparar valores primitivos. Para objetos, se recomienda usar equals().

¿Cuál de las siguientes no es una palabra reservada en Java?
a) static
b) try
c) new
d) define
 Respuesta correcta: d
 'define' no es una palabra reservada en Java, aunque lo es en otros lenguajes como C.

¿Qué clase se utiliza para leer datos desde la consola?
a) InputReader
b) Scanner
c) ConsoleReader
d) BufferReader
 Respuesta correcta: b
 Scanner es la clase comúnmente usada para leer datos desde consola en Java.

¿Cuál de las siguientes estructuras es una clase contenedora?
a) Array
b) List
c) int
d) char
 Respuesta correcta: b
 List es una interfaz de colección que representa una lista ordenada de elementos.

¿Cuál es la salida de System.out.println(3 + "4")?
a) 7
b) 34
c) Error
d) "7"
 Respuesta correcta: b
 Se concatena 3 con el String "4", dando como resultado "34".

¿Qué significa que Java sea un lenguaje fuertemente tipado?
a) Que se puede cambiar el tipo de una variable libremente.
b) Que se deben declarar todos los tipos de datos.
c) Que es sensible a mayúsculas.
d) Que no se pueden usar tipos primitivos.
 Respuesta correcta: b
 En Java todos los tipos deben ser declarados explícitamente y no se permite el cambio de tipo implícito en la mayoría de los casos.

Una interfaz sirve para:
a) Almacenar datos numéricos.
b) Definir una serie de funcionalidades que se implementarán en las clases.
c) Heredar de una clase abstracta.
d) Implementar los métodos abstractos de una clase abstracta.
 Respuesta correcta: b
 Las interfaces definen un contrato que debe implementarse en las clases.

Una interfaz puede heredar de:
a) Una clase.
b) Nada. Las interfaces no pueden heredar.
c) Una o más interfaces.
d) Una cadena.
 Respuesta correcta: c
 En Java, una interfaz puede heredar de múltiples interfaces.

Un método declarado, pero no implementado, en una interfaz se llama:
a) Método estático.
b) Método abstracto.
c) Método de cabecera.
d) Método público.
 Respuesta correcta: b
 Son métodos abstractos porque no tienen cuerpo, solo la firma.

En una interfaz se pueden definir:
a) Sólo atributos.
b) Sólo métodos abstractos.
c) Atributos, métodos abstractos y métodos no abstractos.
d) Solo métodos públicos.
 Respuesta correcta: c
 Desde Java 8, una interfaz puede contener métodos default y estáticos, además de constantes.

El criterio de orden natural en una clase es:
a) El criterio más lógico.
b) El criterio implementado en el método compareTo().
c) El criterio más ecológico.
d) El criterio implementado en la interfaz Comparator.
 Respuesta correcta: b
 El método compareTo() define el orden natural cuando una clase implementa Comparable.

La interfaz Comparator se implementa en:
a) Una clase que queremos ordenar.
b) Una clase que queremos comparar con otra.
c) Una clase cuyos objetos queremos usar para comparar objetos.
d) Un array.
 Respuesta correcta: c
 Comparator es una interfaz funcional que define objetos que comparan otros objetos.

El método compare() es invocado por:
a) Un objeto que queremos comparar.
b) Una clase que implementa la interfaz Comparator.
c) Una clase que implementa la interfaz Comparable.
d) Un objeto de una clase que implementa Comparator.

Una excepción en Java:
a) Se produce cuando un disco está defectuoso.
b) Es un valor único de una variable.
c) Se arroja al sistema cuando se produce una condición anómala durante la ejecución de un programa.
d) Tiene lugar cuando un código es sintácticamente incorrecto.
 Respuesta correcta: c
 Las excepciones son condiciones anómalas que ocurren durante la ejecución del programa.

Una excepción comprobada es:
a) Una excepción que hemos reparado.
b) Una excepción que no detiene la ejecución del programa.
c) Una excepción previsible, que el propio compilador nos obliga a gestionar.
d) Una excepción muy conocida.
 Respuesta correcta: c
 Son aquellas que el compilador fuerza a capturar o declarar con `throws`.

Cuando llegamos al final de un flujo de entrada de tipo FileReader, el método read():
a) Muestra el mensaje: End of File
b) Devuelve null.
c) Produce una excepción EOFException
d) Devuelve −1.
 Respuesta correcta: d
 `read()` devuelve -1 cuando se llega al final del archivo.

La palabra reservada finally:
a) Termina la ejecución de un programa.
b) Termina la ejecución de un método, forzando el return.
c) En una estructura try-catch, fuerza la ejecución de su bloque antes de que se ejecute una sentencia return e independientemente de si se produce o no una excepción.
d) Indica el final de un método.
 Respuesta correcta: c
 `finally` siempre se ejecuta, ocurra o no una excepción.

Un flujo de tipo BufferedReader:
a) Crea un archivo de texto con búfer.
b) Solo sirve para leer cadenas de caracteres.
c) Nos permite acceder a archivos binarios.
d) Accede a un archivo de texto para lectura con búfer.
 Respuesta correcta: d
 Se usa para leer texto de manera eficiente, línea por línea.

La clase Scanner:
a) Solo permite leer texto de cualquier flujo de texto.
b) Permite digitalizar imágenes.
c) Permite leer y analizar texto de cualquier flujo de entrada de texto.
d) Solo nos permite leer de la consola.
 Respuesta correcta: c
 Scanner puede leer de consola, archivos, cadenas, etc.

Para cambiar de línea al escribir en el flujo salida de tipo BufferedWriter debemos ejecutar:
a) salida.write(“\n”)
b) salida.write(“\r\n”)
c) salida.write(“newLine”)
d) salida.newLine()
 Respuesta correcta: d
 `BufferedWriter.newLine()` agrega una nueva línea de forma segura y portátil.

Nos tenemos que asegurar de que todos los flujos abiertos deben cerrarse antes de que termine la aplicación...
a) Porque se quedarían abiertos hasta que se apague el ordenador.
b) Porque otra aplicación podría alterarlos.
c) Porque se deben liberar los recursos asociados, como los archivos. Además, podrían quedar caracteres del búfer sin escribir.
d) Porque se pueden borrar datos de un archivo.
 Respuesta correcta: c
 Cerrar los flujos garantiza que los datos se escriben correctamente y se libera memoria.

Los flujos se cierran:
a) Con el método close().
b) Apagando el ordenador.
c) Abortando el programa.
d) Con el método cerrar().
 Respuesta correcta: a
 `close()` es el método estándar para cerrar flujos en Java.

Apertura de flujos con recursos:
a) Consiste en abrir flujos asociados con varios archivos a la vez.
b) Es abrir archivos recurriendo a una tabla.
c) Es una nueva forma de abrir flujos en Java, que permite prescindir del cierre explícito de los archivos y del método close().
d) Consiste en abrir flujos sin peligro de que se produzcan excepciones.
 Respuesta correcta: c
 Java 7 introdujo `try-with-resources`, que cierra automáticamente los recursos.

¿Para qué sirve la clase File en Java?
a) Para crear interfaces gráficas.
b) Para manipular rutas, archivos y directorios.
c) Para leer y escribir ficheros de texto.
d) Para cifrar ficheros.
 Respuesta correcta: b
 La clase `File` permite manejar rutas, comprobar existencia de archivos, crear o borrar ficheros y directorios.

¿Qué método se utiliza para comprobar si un archivo existe?
a) existsFile()
b) isAvailable()
c) exists()
d) fileFound()
 Respuesta correcta: c
 El método `exists()` de la clase `File` retorna true si el archivo o carpeta existe.

¿Qué clase se usa para escribir texto en un archivo?
a) FileReader
b) File
c) FileWriter
d) FileInputStream
 Respuesta correcta: c
 `FileWriter` se usa para escribir caracteres en un archivo.

¿Con qué clase combinamos BufferedWriter para mejorar el rendimiento al escribir archivos?
a) Scanner
b) File
c) FileWriter
d) InputStream
 Respuesta correcta: c
 `BufferedWriter` se usa junto con `FileWriter` para mejorar el rendimiento mediante búfer de escritura.

¿Qué diferencia hay entre FileWriter y FileOutputStream?
a) FileWriter escribe bytes, FileOutputStream caracteres.
b) FileWriter trabaja con texto, FileOutputStream con bytes.
c) Ambas son iguales.
d) FileWriter solo sirve para leer archivos.
 Respuesta correcta: b
 `FileWriter` es para texto (caracteres) y `FileOutputStream` para datos binarios (bytes).

¿Qué clase se utiliza para leer objetos guardados en un archivo binario?
a) ObjectOutputStream
b) DataInputStream
c) ObjectInputStream
d) FileReader
 Respuesta correcta: c
 `ObjectInputStream` se usa para leer objetos previamente serializados con `ObjectOutputStream`.

Para que un objeto pueda guardarse en un archivo binario, su clase debe:
a) Extender la clase File.
b) Implementar la interfaz Serializable.
c) Usar anotaciones específicas.
d) Ser pública.
 Respuesta correcta: b
 La interfaz `Serializable` marca que los objetos de esa clase se pueden guardar como secuencia de bytes.

¿Cuál es el propósito de try-with-resources?
a) Evitar errores de compilación.
b) Declarar múltiples métodos en una clase.
c) Manejar múltiples excepciones.
d) Cerrar automáticamente los recursos abiertos como flujos.
 Respuesta correcta: d
 Es una forma segura de manejar recursos que necesitan cerrarse automáticamente.

¿Qué clase permite leer archivos binarios byte a byte?
a) FileInputStream
b) BufferedReader
c) Scanner
d) PrintWriter
 Respuesta correcta: a
 `FileInputStream` permite acceder a los archivos binarios como flujo de bytes.


¿Los ficheros binarios se diferencian de los de texto en que...?
a) Solo tienen ceros y unos.
b) Sirven tanto para escribir como para leer.
c) No sirven para guardar texto.
d) Permiten guardar todo tipo de datos, incluidos datos primitivos y objetos.
 Respuesta correcta: d
 Los archivos binarios permiten guardar datos primitivos y objetos, no solo texto plano.

Si queremos guardar una cadena de caracteres en un flujo binario de tipo ObjectOutputStream, usaremos:
a) writeString().
b) writeChar().
c) writeObject().
d) Nada, no se puede.
 Respuesta correcta: c
 Con writeObject() puedes guardar cualquier objeto, incluyendo String, si implementa Serializable.

Para guardar una tabla del tipo int[] en un fichero binario con ObjectOutputStream, usaremos:
a) writeInt().
b) writeArrayInt().
c) readObject().
d) writeObject().
 Respuesta correcta: d
 Las tablas también son objetos en Java, así que deben guardarse con writeObject().

Si queremos leer una tabla de cadenas de caracteres de un flujo ObjectInputStream, escribiremos:
a) String[] tabla = (String[]) entrada.readObject();
b) String tabla = (String) entrada.readObject();
c) String[] tabla = entrada.readObject();
d) String[] tabla = (Object).readObject();
 Respuesta correcta: a
 Hay que hacer un casting correcto al tipo deseado (String[]), porque readObject() devuelve un Object.

Un flujo de tipo ObjectInputStream permite leer de:
a) Cualquier archivo de Windows.
b) Archivos de imagen con extensión JPG.
c) Archivos creados con un flujo ObjectOutputStream.
d) Archivos creados con un flujo BufferedReader.
 Respuesta correcta: c
 Solo puede leer archivos binarios serializados previamente con ObjectOutputStream.

Un flujo de tipo ObjectInputStream permite acceder a:
a) Solo archivos del disco duro.
b) Cualquier fuente de datos primitivos u objetos de Java.
c) Únicamente a conexiones de red.
d) Solo nos permite leer de la consola.
 Respuesta correcta: b
 Puede leer datos desde archivos, sockets u otros flujos, siempre que el contenido sea compatible.

Si guardamos una cadena de caracteres usando ObjectOutputStream, podemos leerla directamente del archivo:
a) Usando un procesador de texto.
b) Usando un editor de texto.
c) Usando una hoja de cálculo.
d) Usando un flujo ObjectInputStream.
 Respuesta correcta: d
 Los datos binarios solo se pueden leer correctamente desde Java mediante ObjectInputStream.

Si guardamos una serie de objetos con ObjectOutputStream, los recuperaremos:
a) En el mismo orden en que se guardaron.
b) En orden inverso.
c) En un orden aleatorio.
d) Nunca se pueden recuperar.
 Respuesta correcta: a
 La serialización conserva el orden de escritura, y deben recuperarse en el mismo orden.

Los flujos binarios se cierran:
a) Con el método close().
b) Apagando el ordenador.
c) Abortando el programa.
d) Con el método cerrar().
 Respuesta correcta: a
 Como en otros flujos, close() es el método correcto para liberar recursos.

¿Hay que cerrar los flujos binarios?
a) Siempre.
b) Una vez al día.
c) Solo si no se han abierto con una estructura try-catch con recursos.
d) Nunca.
 Respuesta correcta: a
 Es una buena práctica cerrar siempre los flujos para liberar recursos y evitar pérdida de datos.

¿Qué es Collection?
a) Una interfaz.
b) Una clase.
c) Un sistema operativo.
d) Un método.
 Respuesta correcta: a
 Collection es una interfaz raíz del marco de colecciones de Java que agrupa tipos como List, Set y Queue.

¿Para qué sirven los tipos genéricos?
a) Usar objetos de la clase Object.
b) Usar variables primitivas.
c) Usar tipos parametrizados.
d) No tener que usar ningún tipo.
 Respuesta correcta: c
 Los genéricos permiten definir estructuras con tipos de datos específicos, aumentando la seguridad y evitando conversiones.

¿Para qué sirve una lista?
a) Guardar datos primitivos.
b) Guardar datos que no se pueden repetir.
c) No tener que ordenar un conjunto de datos.
d) Guardar, de forma dinámica, datos que se pueden repetir y ordenar.
 Respuesta correcta: d
 Las listas (List) permiten almacenar datos en orden y con posibles repeticiones.

Un conjunto es una colección de elementos:
a) Que no admiten orden.
b) Que admiten repeticiones.
c) Que no se pueden alterar.
d) Cuyo criterio fundamental es el de pertenecer al conjunto.
 Respuesta correcta: d
 Un conjunto (Set) se define por la pertenencia, sin duplicados.

ArrayList y LinkedList se diferencian:
a) En el número de elementos.
b) En el rendimiento.
c) En el orden de los elementos.
d) En nada.
 Respuesta correcta: b
 ArrayList tiene mejor acceso aleatorio, LinkedList es mejor para inserciones o eliminaciones frecuentes.

Los métodos de la interfaz Set:
a) Son los mismos que los de List.
b) Son los mismos que los de Collection.
c) Son implementados en la clase ArrayList.
d) Esta interfaz no tiene métodos.
 Respuesta correcta: b
 Set hereda de Collection, por lo tanto, sus métodos básicos son los mismos.

Si la variable a referencia un objeto ArrayList, la expresión new TreeSet(a):
a) Devuelve un conjunto ordenado con los elementos de a.
b) Es incorrecta.
c) Devuelve una lista ordenada.
d) Devuelve una tabla.
 Respuesta correcta: a
 TreeSet ordena automáticamente los elementos del ArrayList que se le pasa.

¿Qué es Collections?
a) Una clase cuyos objetos están repetidos.
b) Una interfaz de la que heredan todas las colecciones.
c) Una clase con métodos estáticos que sirven para gestionar colecciones.
d) Nada, le sobra la 's'.
 Respuesta correcta: c
 Collections es una clase utilitaria con métodos estáticos como sort(), reverse(), etc.

Un mapa en Java es:
a) Un gráfico con las relaciones de herencia entre interfaces.
b) Una colección.
c) Una representación de los datos por pantalla.
d) Una estructura dinámica cuyos elementos son parejas clave-valor.
 Respuesta correcta: d
 Los mapas (Map) almacenan datos en pares clave-valor.

Si queremos cambiar el valor de una entrada en un mapa, usaremos el método:
a) put().
b) set().
c) add().
d) insert().
 Respuesta correcta: a
 put(clave, nuevoValor) actualiza o inserta una nueva entrada en el mapa.

¿Qué es Collection?
a) Una interfaz.
b) Una clase.
c) Un sistema operativo.
d) Un método.
 Respuesta correcta: a
 Collection es una interfaz raíz del marco de colecciones de Java que agrupa tipos como List, Set y Queue.

¿Para qué sirven los tipos genéricos?
a) Usar objetos de la clase Object.
b) Usar variables primitivas.
c) Usar tipos parametrizados.
d) No tener que usar ningún tipo.
 Respuesta correcta: c
 Los genéricos permiten definir estructuras con tipos de datos específicos, aumentando la seguridad y evitando conversiones.

¿Para qué sirve una lista?
a) Guardar datos primitivos.
b) Guardar datos que no se pueden repetir.
c) No tener que ordenar un conjunto de datos.
d) Guardar, de forma dinámica, datos que se pueden repetir y ordenar.
 Respuesta correcta: d
 Las listas (List) permiten almacenar datos en orden y con posibles repeticiones.

Un conjunto es una colección de elementos:
a) Que no admiten orden.
b) Que admiten repeticiones.
c) Que no se pueden alterar.
d) Cuyo criterio fundamental es el de pertenecer al conjunto.
 Respuesta correcta: d
 Un conjunto (Set) se define por la pertenencia, sin duplicados.

ArrayList y LinkedList se diferencian:
a) En el número de elementos.
b) En el rendimiento.
c) En el orden de los elementos.
d) En nada.
 Respuesta correcta: b
 ArrayList tiene mejor acceso aleatorio, LinkedList es mejor para inserciones o eliminaciones frecuentes.

Los métodos de la interfaz Set:
a) Son los mismos que los de List.
b) Son los mismos que los de Collection.
c) Son implementados en la clase ArrayList.
d) Esta interfaz no tiene métodos.
 Respuesta correcta: b
 Set hereda de Collection, por lo tanto, sus métodos básicos son los mismos.

Si la variable a referencia un objeto ArrayList, la expresión new TreeSet(a):
a) Devuelve un conjunto ordenado con los elementos de a.
b) Es incorrecta.
c) Devuelve una lista ordenada.
d) Devuelve una tabla.
 Respuesta correcta: a
 TreeSet ordena automáticamente los elementos del ArrayList que se le pasa.

¿Qué es Collections?
a) Una clase cuyos objetos están repetidos.
b) Una interfaz de la que heredan todas las colecciones.
c) Una clase con métodos estáticos que sirven para gestionar colecciones.
d) Nada, le sobra la 's'.
 Respuesta correcta: c
 Collections es una clase utilitaria con métodos estáticos como sort(), reverse(), etc.

Un mapa en Java es:
a) Un gráfico con las relaciones de herencia entre interfaces.
b) Una colección.
c) Una representación de los datos por pantalla.
d) Una estructura dinámica cuyos elementos son parejas clave-valor.
 Respuesta correcta: d
 Los mapas (Map) almacenan datos en pares clave-valor.

Si queremos cambiar el valor de una entrada en un mapa, usaremos el método:
a) put().
b) set().
c) add().
d) insert().
 Respuesta correcta: a
 put(clave, nuevoValor) actualiza o inserta una nueva entrada en el mapa.

Sobre una subclase es correcto afirmar que:
a) Tiene menos atributos que su superclase.
b) Tiene menos miembros que su superclase.
c) Hereda los miembros no privados de su superclase.
d) Hereda todos los miembros de su superclase.
 Respuesta correcta: c
 Una subclase hereda los miembros públicos y protegidos de su superclase, no los privados.

En relación con las clases abstractas es correcto señalar que:
a) Implementan todos sus métodos.
b) No implementan ningún método.
c) No tienen atributos.
d) Tienen algún método abstracto.
 Respuesta correcta: d
 Las clases abstractas pueden tener métodos implementados y atributos, pero deben tener al menos un método abstracto.

¿En qué consiste la sustitución u overriding?
a) En sustituir un método heredado por otro implementado en la propia clase.
b) En sustituir un atributo por otro del mismo nombre.
c) En sustituir una clase por una subclase.
d) En sustituir un valor de una variable por otro.
 Respuesta correcta: a
 Overriding es redefinir un método heredado en una subclase con una nueva implementación.

Sobre la clase Object es cierto indicar que:
a) Es abstracta.
b) Hereda de todas las demás.
c) Tiene todos sus métodos abstractos.
d) Es superclase de todas las demás clases.
 Respuesta correcta: d
 Object es la superclase de todas las clases en Java.

¿Cuál de las siguientes afirmaciones sobre el método equals() es correcta?
a) Hay que implementarlo, ya que es abstracto.
b) Sirve para comparar solo objetos de la clase Object.
c) Se hereda de Object, pero debemos reimplementarlo al definirlo en una clase.
d) No hay que implementarlo, ya que se hereda de Object.
 Respuesta correcta: c
 Se hereda de Object, pero se recomienda sobrescribirlo para una comparación personalizada.

¿Cuál de las siguientes afirmaciones sobre el método toString() es correcta?
a) Sirve para mostrar la información que nos interesa de un objeto.
b) Convierte automáticamente un objeto en una cadena.
c) Encadena varios objetos.
d) Es un método abstracto de Object que tenemos que implementar.
 Respuesta correcta: a
 toString() sirve para devolver una representación textual personalizada de un objeto.

¿Cuál de las siguientes afirmaciones sobre el método getClass() es correcta?
a) Convierte los objetos en clases.
b) Obtiene la clase a la que pertenece un objeto.
c) Obtiene la superclase de una clase.
d) Obtiene una clase a partir de su nombre.
 Respuesta correcta: b
 getClass() devuelve la clase real del objeto en tiempo de ejecución.

Una clase puede heredar:
a) De una clase.
b) De dos clases.
c) De todas las clases que queramos.
d) Solo de la clase Object.
 Respuesta correcta: a
 En Java solo se permite heredar de una única clase (herencia simple).

La selección dinámica de métodos:
a) Se produce cuando una variable cambia de valor durante la ejecución de un programa.
b) Es el cambio de tipo de una variable en tiempo de ejecución.
c) Es la asignación de un mismo objeto a más de una variable en tiempo de ejecución.
d) Es la ejecución de distintas implementaciones de un mismo método, asignando objetos de distintas clases a una misma variable, en tiempo de ejecución.
 Respuesta correcta: d
 Esto es polimorfismo: permite ejecutar la versión del método correspondiente al tipo real del objeto.

¿Cuál de las siguientes afirmaciones sobre el método super() es correcta?
a) Sirve para llamar al constructor de la superclase.
b) Sirve para invocar un método escrito más arriba en el código.
c) Sirve para llamar a cualquier método de la superclase.
d) Sirve para hacer referencia a un atributo de la superclase.
 Respuesta correcta: a
 super() se usa para llamar al constructor de la clase base desde una subclase.

¿Cuál es el tipo de retorno del método main en Java?
a) void
b) int
c) String
d) boolean
 Respuesta correcta: a
 El método main debe ser public static void main(String[] args), por eso retorna void.

¿Qué palabra clave se utiliza para heredar una clase en Java?
a) this
b) extends
c) implements
d) instanceof
 Respuesta correcta: b
 La palabra clave extends se utiliza para heredar de una clase base.